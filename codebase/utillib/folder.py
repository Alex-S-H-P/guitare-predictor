from typing import Generic, TypeVar, Iterable, Any, Sized

T = TypeVar('T')  # do not use T anywhere else


class Queue(Generic[T]):

    def __init__(self, space: int):
        assert space > 0, f"can't define queue that small {space}"
        self.array: list[T | None] = [None for _ in range(space)]
        self._ptr: int = 0

    @property
    def ptr(self) -> int:
        if self._ptr < 0 or self._ptr >= len(self):
            self._ptr = self._ptr % len(self)
        return self._ptr

    def put(self, el: T):
        self.array[self.ptr] = el
        self._ptr += 1
        return self.array

    def __iter__(self):
        for offset in range(1, len(self) + 1):
            val = self.array[(self.ptr - offset) % len(self)]
            if val is not None:
                yield val
            else:
                return

    def __getitem__(self, offset: int | slice) -> Iterable[T] | T:
        if isinstance(offset, slice):
            stop = min(offset.stop if offset.stop is not None else len(self), len(self))
            start = max(offset.start if offset.start is not None else 0, 0)
            step = min(offset.step if offset.step is not None else 1, 1)
            return [self.array[(self.ptr - offset) % len(self)] for offset in range(start + 1, stop + 1, step)]

        elif not isinstance(offset, int):
            raise ValueError("Cannot access non int array index")
        return self.array[(self.ptr - offset) % len(self)]

    def __len__(self):
        return len(self.array)


def maxOccur(iterable: Sized):
    """
    Returns the element that occurs the most.
    Equality is determined by the __hash__ method
    """
    if len(iterable) == 0:
        return None
    counter: dict[Any, int] = {}
    for e in iterable:
        if e in counter:
            counter[e] += 1
        else:
            counter[e] = 1

    return [e for e in counter if (counter[e] == max(counter.values()))][0]


Note = dict[str, str | float | int]
Partition = list[Note]


def foldArrayOfNotes(array: list[str], beats_per_minute: int | float, metric_per_beats: int | float,
                     noteChangeThreshold: float, sliding_size: int = None) -> Partition:
    """
    :param array: the array of notes generated by the model
    :param beats_per_minute: the number of beats per minutes as found in the music
    :param metric_per_beats: the number of measures we did per beat
    :param noteChangeThreshold: the frequency of a new note required to find that we have a different note.
        Should be smaller for longer sliding sizes
    :param sliding_size: the number of notes being considered to detect a change in notes.
        Defaults to the number of metrics in a second
    :return: the array that, to a note, indicates length in beats, in seconds, as well as the note played.
    """
    r : Partition = [{"start_index": 0}]
    if sliding_size is None:
        sliding_size = min(int(beats_per_minute * metric_per_beats / 60), 3)  # the number of metrics in a second
    slidingWindow: Queue[str] = Queue(sliding_size)

    index_since_last_change = 0
    last_note_on_change = array[0]
    # mainloop
    for i, val in enumerate(array):
        slidingWindow.put(val)
        index_since_last_change += 1
        presence_slice: list[str] = slidingWindow[:index_since_last_change]
        presence: float = len([item
                               for item in presence_slice
                               if item == val
                               ]) / len(presence_slice)  # frequency of val in the sliding window
        print(f"> {i}, {val}, {presence:.2f} {last_note_on_change}", presence_slice,
              "\033[33mchange\033[0m"
              if (presence > noteChangeThreshold)
              and (len(presence_slice)) * presence < index_since_last_change
              and (val != last_note_on_change)
              else "\033[32mstay\033[0m")
        if presence > noteChangeThreshold and val != last_note_on_change:
            di = int(min(
                len(presence_slice) * presence,
                sliding_size) + .5
                     )  # the number of steps that the presence was computed on
            if di < index_since_last_change:
                print("\t", di, index_since_last_change - di)
                r[-1]["len"] = index_since_last_change - di
                index_since_last_change = di
                last_note_on_change = val
                r.append({"start_index": i - di})
    r[-1]["len"] = index_since_last_change

    def getRange(n: Note) -> range:
        if "len" in n:
            return range(n["start_index"], n["start_index"] + n["len"])
        else:
            return range(n["start_index"], len(array))

    for j, s in enumerate(r):
        r[j]["note"] = maxOccur([array[i] for i in getRange(s)])[:-1]
        r[j]["beats"] = r[j]["len"] / metric_per_beats  # le nombre de battements
        r[j]["duration"] = r[j]["beats"] * 60 / beats_per_minute  # le nombre de secondes
    return r


if __name__ == '__main__':
    t_array = ["A", "A", "A", "A", "B", "B", "C", "B", "B", "B", "B", "B", "B", "A", "A", "A", "A"]
    print(*foldArrayOfNotes(t_array, 60, 1, 3 / 5, 5), sep="\n\t")
